interface ServerlessError {
    message: string;
    code: string;
}
declare class DatabaseError extends Error {
    details: ServerlessError | null;
    status: number;
    constructor(message: string, status: number, details: ServerlessError | null);
}

type Req = {
    method: string;
    headers: Record<string, string>;
    body: string;
    cache?: RequestCache;
};
type Res = {
    ok: boolean;
    status: number;
    statusText: string;
    headers: any;
    json(): Promise<any>;
    text(): Promise<string>;
};
interface Config {
    url?: string;
    username?: string;
    password?: string;
    database?: string;
    host?: string;
    fetch?: (input: string, init?: Req) => Promise<Res>;
    arrayMode?: boolean;
    fullResult?: boolean;
    decoders?: Decoders;
    debug?: boolean;
}
interface ExecuteOptions {
    arrayMode?: boolean;
    fullResult?: boolean;
    decoders?: Decoders;
    debug?: boolean;
}
interface TxOptions {
    isolation?: 'READ COMMITTED' | 'REPEATABLE READ';
}
type ExecuteArgs = object | any[] | null;
declare const enum ColumnType {
    TINYINT = "TINYINT",
    UNSIGNED_TINYINT = "UNSIGNED TINYINT",
    SMALLINT = "SMALLINT",
    UNSIGNED_SMALLINT = "UNSIGNED SMALLINT",
    MEDIUMINT = "MEDIUMINT",
    UNSIGNED_MEDIUMINT = "UNSIGNED MEDIUMINT",
    INT = "INT",
    UNSIGNED_INT = "UNSIGNED INT",
    YEAR = "YEAR",
    FLOAT = "FLOAT",
    DOUBLE = "DOUBLE",
    BIGINT = "BIGINT",
    UNSIGNED_BIGINT = "UNSIGNED BIGINT",
    DECIMAL = "DECIMAL",
    CHAR = "CHAR",
    VARCHAR = "VARCHAR",
    BINARY = "BINARY",
    VARBINARY = "VARBINARY",
    TINYTEXT = "TINYTEXT",
    TEXT = "TEXT",
    MEDIUMTEXT = "MEDIUMTEXT",
    LONGTEXT = "LONGTEXT",
    TINYBLOB = "TINYBLOB",
    BLOB = "BLOB",
    MEDIUMBLOB = "MEDIUMBLOB",
    LONGBLOB = "LONGBLOB",
    DATE = "DATE",
    TIME = "TIME",
    DATETIME = "DATETIME",
    TIMESTAMP = "TIMESTAMP",
    BIT = "BIT",
    JSON = "JSON"
}
type Decoders = {
    [P in ColumnType]?: (rawValue: string) => any;
};

type Row = Record<string, any> | any[];
type Types = Record<string, string>;
interface FullResult {
    types: Types | null;
    rows: Row[] | null;
    statement: string;
    rowCount: number | null;
    rowsAffected: number | null;
    lastInsertId: string | null;
}
interface Field {
    name: string;
    type: string;
    nullable: boolean;
}
declare class Tx {
    private conn;
    constructor(conn: Connection);
    execute(query: string, args?: ExecuteArgs, options?: ExecuteOptions, txOptions?: TxOptions): Promise<FullResult | Row[]>;
    commit(): Promise<FullResult | Row[]>;
    rollback(): Promise<FullResult | Row[]>;
}
declare class Connection {
    private config;
    private session;
    constructor(config: Config);
    getConfig(): Config;
    begin(txOptions?: TxOptions): Promise<Tx>;
    execute(query: string, args?: ExecuteArgs, options?: ExecuteOptions, txOptions?: TxOptions): Promise<FullResult | Row[]>;
}
declare function connect(config: Config): Connection;

export { ColumnType, Config, Connection, DatabaseError, Decoders, ExecuteArgs, ExecuteOptions, Field, FullResult, Row, Tx, Types, connect };
